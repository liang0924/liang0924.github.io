<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第三章  处理机调度和死锁</title>
    <url>/2020/04/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="第三章-处理机调度和死锁"><a href="#第三章-处理机调度和死锁" class="headerlink" title="第三章  处理机调度和死锁"></a>第三章  处理机调度和死锁</h3><h4 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1  处理机调度的层次和调度算法的目标"></a>3.1  处理机调度的层次和调度算法的目标</h4><ul>
<li><h5 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h5><p>1&gt;高级调度：长程调度或作业调度。将外存上的作业调入内存。</p>
<p>2&gt;低级调度：进程调度或短程调度，根据某种算法给进程分配处理机。</p>
<p>3&gt;中级调度：内存调度，将暂时不能运行的进程调至外存等待，此时进程为挂起状态。以后再由中级调度来</p>
<p>​                        把外存上的那些具有运行条件的就绪进程再重新调入内存，修改为就绪状态。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第二章  进程的描述与控制</title>
    <url>/2020/04/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章  进程的描述与控制"></a>第二章  进程的描述与控制</h3><h4 id="2-1-前驱图和程序执行"><a href="#2-1-前驱图和程序执行" class="headerlink" title="2.1  前驱图和程序执行"></a>2.1  前驱图和程序执行</h4><ul>
<li><p>前驱图是指一个有向无循环图，用于描述进程之间执行的先后顺序。</p>
</li>
<li><p>一个应用程序由若干程序段组成，每一程序段完成特定的功能，它们在执行时，都需 </p>
<p>要按照某种先后次序执行。程序执行具有三个特征，顺序性、封闭性、可再现性。</p>
</li>
<li><p>程序的并发执行：不存在前驱关系的程序之间可以并发执行。三个新特征：间断性、失去封闭性、不可再现性</p>
</li>
</ul>
<h4 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2  进程的描述"></a>2.2  进程的描述</h4><ul>
<li><h5 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h5><p>通常的程序不能参与并发执行，为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，引入进程的概念。</p>
<p>创建进程就是创建进程实体中的PCB(进程控制块)，进程实体由程序段、相关的数据段和PCB构成。</p>
<p>进程是程序的一次运行，是系统进行资源分配和调度的一个独立单位。</p>
</li>
<li><h5 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h5><p>①动态性：进程实体具有生命周期</p>
<p>②并发性</p>
<p>③独立性</p>
<p>④异步性：进程按各自独立，不可预见的速度向前推进，但通过进程同步机制，仍能保证并发执行的结果是可再现的。</p>
</li>
<li><h5 id="进程的三种状态"><a href="#进程的三种状态" class="headerlink" title="进程的三种状态"></a>进程的三种状态</h5><p>就绪状态、执行状态、阻塞状态。</p>
<img src="D:\简历及面试\基本概念\操作系统及网络\img\图片1.png" style="zoom:70%;" />
</li>
<li><h5 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h5><p>1&gt;进程控制块PCB的作用：作为独立运行基本单位的标志，用于描述进程的当前情况以及管理进程运行的全部信息，保存CPU现场信息以实现间断性运行。还能实现与其他进程的同步与通信。</p>
<p>2&gt;进程控制块中的信息：①进程标识符  ②处理机状态  ③进程调度信息  ④进程控制信息</p>
<p>3&gt;进程控制块的组织方式：①线性方式  ②链接方式  ③索引方式</p>
</li>
</ul>
<h4 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3  进程控制"></a>2.3  进程控制</h4><p>进程控制是进程管理中最基本的功能，进程控制一般是由OS的内核中的原语来实现的。</p>
<ul>
<li><h5 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h5><p>一些与硬件紧密相关的模块，各种常用设备的驱动程序以及运行频率较高的模块，都安装在紧靠硬件的软件层次中，将它们常驻内存，称为OS内核。</p>
<p>处理机的执行状态：1&gt;系统态，又称管态或内核态。2&gt;用户态，又称目态。</p>
<p>OS内核的两大功能：1&gt;支撑功能。2&gt;资源管理功能</p>
</li>
<li><h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5></li>
<li><h5 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h5></li>
<li><h5 id="进程的阻塞和唤醒：block和wakeup"><a href="#进程的阻塞和唤醒：block和wakeup" class="headerlink" title="进程的阻塞和唤醒：block和wakeup"></a>进程的阻塞和唤醒：block和wakeup</h5></li>
<li><h5 id="进程的挂起和激活：suspend和active"><a href="#进程的挂起和激活：suspend和active" class="headerlink" title="进程的挂起和激活：suspend和active"></a>进程的挂起和激活：suspend和active</h5></li>
</ul>
<h4 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4  进程同步"></a>2.4  进程同步</h4><ul>
<li><h5 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h5><p>进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则或时序共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。</p>
<p>有两种形式的制约关系，间接和直接相互制约。由于存在制约，故进程运行速度并不能由自身所控制，此即进程的异步性。</p>
<p>临界资源：需要互斥访问。</p>
<p>临界区：访问临界资源的那段代码。相对应的还有进入区，退出区，剩余区。</p>
<p>同步进制应遵循的规则：</p>
<p>1&gt;空闲让进    2&gt;忙则等待    3&gt;有限等待   4&gt;让权等待：释放处理机</p>
</li>
<li><h5 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h5><p>1&gt;关中断</p>
<p>2&gt;利用Test-and-Set指令</p>
<p>3&gt;利用Swap指令实现进程互斥</p>
</li>
<li><h5 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h5><p>1&gt;整型信号量：定义一个表示资源数目的整型量S,通过wait和signal操作访问，会出现忙等状态。</p>
<p>2&gt;记录型信号量：有两个变量，一个是表示资源数目的整型变量value，一个是进程列表指针list。</p>
<p>​                                当资源数为0时，使用block原语自我阻塞，放弃处理机。</p>
<p>3&gt;AND型信号量：将进程需要的所有资源一次性全部分配给进程，只要有一个分配不了，其他资源也不分配</p>
<p>4&gt;信号量集：可以一次分配多个资源。Swait(S1,t1,d1,…,Sn,tn,dn)。</p>
<p>​                        t：分配下限值，S必须大于或等于它才能进行资源分配    d：资源需求值。</p>
</li>
<li><h5 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h5><p>1&gt;利用信号量实现进程互斥</p>
<p>2&gt;利用信号量实现前趋关系</p>
</li>
</ul>
<h4 id="2-7-线程的基本概念"><a href="#2-7-线程的基本概念" class="headerlink" title="2.7  线程的基本概念"></a>2.7  线程的基本概念</h4><ul>
<li><h5 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h5><p>在OS中引入进程的目的是为了使多个进程能并发执行，以提高资源利用率和系统吞吐量。在OS中引入线程则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p>
<p>1&gt;进程的两个基本属性：可拥有资源的独立单位；可独立调度和分派的基本单位。</p>
<p>2&gt;程序并发执行所需付出的时空开销</p>
<p>​    1.创建进程    2.撤销进程    3.进程切换</p>
<p>3&gt;线程—-作为调度和分派的基本单位。</p>
</li>
<li><h5 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h5><p>1&gt;  引入线程后调度的基本单位是线程，线程是能独立运行的基本单位，线程切换时代价小，且不会引起进程的切换。</p>
<p>2&gt;  一个进程中的多个线程也可以并发执行。</p>
<p>3&gt;  进程可以拥有资源，线程本身不拥有资源，只有一点能保证独立运行的资源，一个进程中的多个线程共享该进程所拥有的资源。同一进程的线程拥有相同的地址空间，所以独立性低。</p>
<p>4&gt;  线程的系统开销小，而且支持多处理机系统，一个进程的多个线程可以同时在不同的处理机上运行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第四章  存储管理器</title>
    <url>/2020/04/10/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="第四章-存储管理器"><a href="#第四章-存储管理器" class="headerlink" title="第四章  存储管理器"></a>第四章  存储管理器</h3><h4 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1  存储器的层次结构"></a>4.1  存储器的层次结构</h4><ul>
<li><h5 id="多层结构的存储器系统"><a href="#多层结构的存储器系统" class="headerlink" title="多层结构的存储器系统"></a>多层结构的存储器系统</h5><p>存储管理范畴：寄存器、高速缓存、主存储器，磁盘缓存。掉电后存储的信息不再存在。</p>
<p>设备管理范畴：固定磁盘、可移动存储介质。存储的信息被长期保存。</p>
</li>
</ul>
<h4 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2  程序的装入和链接"></a>4.2  程序的装入和链接</h4><p>程序的运行需要经历三个步骤：编译、链接、装入。</p>
<ul>
<li><h5 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h5><p>1.绝对装入方式：用户程序编译后直接产生绝对地址（物理地址），然后装入。</p>
<p>2.可重定位装入方式：将逻辑地址转换成绝对地址。地址变换在进程装入时一次完成的，以后不再改变，故称</p>
<p>​                                      为静态重定位。</p>
<p>3.动态运行时的装入方式：装入时不进行地址转换，程序真正执行时再转换。</p>
</li>
<li><h5 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h5><p>1.静态链接方式：程序运行之前，将各目标模块及它们所需库函数链接成一个完整的装配模块，以后不再分开</p>
<p>2.装入时动态链接：边装入边链接，便于修改和更新，便于实现对目标模块的共享。</p>
<p>3.运行时动态链接：程序执行过程中，再去链接相应模块。</p>
</li>
</ul>
<h4 id="4-3-连续分配存储管理"><a href="#4-3-连续分配存储管理" class="headerlink" title="4.3  连续分配存储管理"></a>4.3  连续分配存储管理</h4><ul>
<li><h5 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h5></li>
<li><h5 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h5><p>1&gt;划分分区的方法：分区大小相等、分区大小不等</p>
<p>2&gt;内存分配：使用分区使用表，将分区按大小进行排队，每个表项包括地址，大小和状态</p>
</li>
<li><h5 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h5><p>根据进程的实际需求，动态地为之分配内存空间。</p>
<p>1&gt;数据结构：空闲分区表，空闲分区链。</p>
<p>2&gt;动态分区分配算法：顺序搜索算法，索引搜索算法</p>
<p>3&gt;分区分配操作：分配内存，回收内存。</p>
</li>
<li><h5 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h5></li>
</ul>
<h4 id="4-4-对换（Swapping）"><a href="#4-4-对换（Swapping）" class="headerlink" title="4.4  对换（Swapping）"></a>4.4  对换（Swapping）</h4><ul>
<li><h5 id="多道程序环境下的对换技术"><a href="#多道程序环境下的对换技术" class="headerlink" title="多道程序环境下的对换技术"></a>多道程序环境下的对换技术</h5><p>1&gt;对换的引入：把内存中暂时不能运行的进程或者暂时不用的程序和数据换到外存中。再把已具备运行条件的进程或进程所需要的程序和数据换入内存。</p>
<p>2&gt;对换的类型：整体对换，页面（分段）对换。</p>
</li>
<li><h5 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h5><p>1&gt;主要目标：磁盘空间主要分为文件区和对换区两部分。</p>
<p>​                        对文件区管理的目标是提高文件存储空间的利用率，采用离散分配方式。</p>
<p>​                        对对换空间管理的目标是提高进程换入和换出的速度，采取连续分配方式。</p>
<p>2&gt;数据结构：与内存在动态分区分配方式中所用数据结构相似。</p>
<p>3&gt;对换空间的分配与回收：也类似动态分区分配。</p>
</li>
<li><h5 id="进程的换入换出"><a href="#进程的换入换出" class="headerlink" title="进程的换入换出"></a>进程的换入换出</h5></li>
</ul>
<h4 id="4-5-离散分配存储管理方式"><a href="#4-5-离散分配存储管理方式" class="headerlink" title="4.5  离散分配存储管理方式"></a>4.5  离散分配存储管理方式</h4><ul>
<li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>连续分配方式会形成许多“碎片”，虽然可以通过“紧凑”方法拼接，但是开销较大。如果允许将一个进程直接分散地装入到许多不相邻接的分区中，便可充分利用内存空间。</p>
</li>
<li><h5 id="三种分配方式"><a href="#三种分配方式" class="headerlink" title="三种分配方式"></a>三种分配方式</h5><p>1&gt;分页存储管理方式：将用户程序的地址空间分为若干个固定大小的区域，称为“页”，典型页面大小为1KB，</p>
<p>​                                       相应的，也将内存空间分为若干物理块或页框，页和块的大小相同。提高利用率。</p>
<p>2&gt;分段存储管理方式：为了满足用户需求，它将用户程序的地址空间分为若干个大小不同的段，每段是一段</p>
<pre><code>完整的信息。在存储分配时，以段为单位。</code></pre><p>3&gt;段页式存储管理方式：先将用户程序分段，再将每个段分页。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第五章  虚拟存储器</title>
    <url>/2020/04/10/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h3 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章  虚拟存储器"></a>第五章  虚拟存储器</h3><h4 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1  虚拟存储器概述"></a>5.1  虚拟存储器概述</h4><p>虚拟存储器从逻辑上实现了对内存容量的扩充。</p>
<ul>
<li><h5 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h5><p>1&gt;特征：一次性、驻留性。</p>
<p>2&gt;局部性原理：程序的执行仅局限于某个部分，它访问的存储空间也局限于某个区域。</p>
<p>​                            时间局限性：指令的重复执行，数据的重复访问。</p>
<p>​                            空间局限性：存储单元集中访问。</p>
<p>3&gt;基本工作情况：程序执行时，若它所要访问的页已调入内存，便继续执行，否则发出缺页中断请求，此时</p>
<p>​                                如果内存已满，OS利用页的置换功能，将内存中暂时不用的页调至盘上。</p>
</li>
<li><h5 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h5><p>1&gt;定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量是</p>
<p>​                由内存容量和外存容量之和所决定的。</p>
<p>2&gt;特征：多次性、对换性、虚拟性。</p>
</li>
<li><h5 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h5><p>建立在离散分配存储管理方式的基础上</p>
<p>1&gt;分页请求系统</p>
<p>2&gt;请求分段系统</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
</search>
